{"version":3,"sources":["webpack:///./resources/js/plugins/stickyElement.plugin.js"],"names":["__webpack_require__","r","__webpack_exports__","jquery__WEBPACK_IMPORTED_MODULE_0__","jquery__WEBPACK_IMPORTED_MODULE_0___default","n","FixedElement","elem","options","$","extend","classWhileFixed","startOffset","stopEarly","that","this","state","$elem","$dupe","clone","addClass","css","visibility","insertAfter","$until","until","$untilVisible","untilVisible","position","startAt","offset","top","endAt","duration","window","height","document","endOffset","release","removeClass","transform","fix","additionalOffset","requestAnimationFrame","update","scrollTop","start","end","diff","currentDiff","diffOffsets","on","fn","each"],"mappings":"kIAAAA,EAAAC,EAAAC,GAAA,IAAAC,EAAAH,EAAA,QAAAI,EAAAJ,EAAAK,EAAAF,GA0DIG,EAAe,SAASC,EAAMC,GAO9BA,EAAUC,IAAEC,OANG,CACXC,gBAAiB,gBACjBC,YAAa,EACbC,UAAW,GAGcL,GAE7B,IAAIM,EAAOC,KACPC,EAAQ,OACRC,EAAQR,IAAEF,GACVW,EAAQD,EACPE,QACAC,SAAS,2BACTC,IAAI,CACDC,WAAY,WAEfC,YAAYN,GAEb,UAAWT,IACXA,EAAQgB,OAASf,IAAED,EAAQiB,QAG3B,iBAAkBjB,IAClBA,EAAQkB,cAAgBjB,IAAED,EAAQmB,eAGtCV,EAAMI,IAAI,CACNO,SAAU,aAGdb,KAAKc,QAAU,WACX,OAAOX,EAAMY,SAASC,IAAMvB,EAAQI,aAGxCG,KAAKiB,MAAQ,WACT,IAAIF,EAASf,KAAKc,UAkBlB,MAhBI,aAAcrB,EACdsB,GAAUtB,EAAQyB,SAElBH,EADO,UAAWtB,EACTA,EAAQgB,OAAOM,SAASC,IAC1B,iBAAkBvB,EAChBA,EAAQkB,cAAcI,SAASC,IAAMtB,IAAEyB,QAAQC,SAE/C1B,IAAE2B,UAAUD,UAIrBL,GADA,cAAetB,EACLA,EAAQ6B,UAER7B,EAAQI,aAGNJ,EAAQK,WAG5BE,KAAKuB,QAAU,SAASP,GACpBf,EAAQ,WACRC,EAAMsB,YAAY/B,EAAQG,iBACrBU,IAAI,CACDO,SAAU,WACVG,IAAK,GACLS,UAAW,8BAAgCT,EAAM,SAI7DhB,KAAK0B,IAAM,SAASC,GAChB,IAAIZ,EAAStB,EAAQI,YAAc8B,EAEnC1B,EAAQ,QACR2B,sBAAsB,WAClB1B,EAAMG,SAASZ,EAAQG,iBAClBU,IAAI,CACDO,SAAU,QACVG,IAAKD,EACLU,UAAW,QAK3BzB,KAAK6B,OAAS,WACV,IAAIC,EAAcpC,IAAEyB,QAAQW,YACxBC,EAAchC,EAAKe,UACnBkB,EAAcjC,EAAKkB,QACnBgB,EAAcD,EAAMD,EACpBG,EAAcJ,EAAYC,EAC1BI,EAAe1C,EAAQ6B,UAAY7B,EAAQI,aAAgB,EAG3DiC,GAAaC,EACA,SAAT9B,GAA6B,QAATA,GACpBF,EAAKwB,QAAQ,GAIVO,GAAaE,EAChBG,EACApC,EAAK2B,IAAIS,EAAcD,EAAcD,GACrB,YAAThC,GAAgC,QAATA,GAC9BF,EAAK2B,IAAI,GAKA,SAATzB,GAA6B,QAATA,GACpBF,EAAKwB,QAAQU,EAAOE,IAKhCzC,IAAEyB,QAAQiB,GAAG,2BAA4BpC,KAAK6B,QAC9C7B,KAAK6B,UAGTnC,IAAE2C,GAAGX,IAAM,SAASjC,GAChBO,KAAKsC,KAAK,WACN,OAAO,IAAI/C,EAAaS,KAAMP","file":"/js/plugins/stickyElement.plugin.js","sourcesContent":["/**\n * This jQuery plugin provides the ability to stick and unstick elements\n * based on the current scroll position. For example,\n *\n * To have an element scroll with the page until it reaches the top, then\n * stick to the page:\n *\n *     $('aside.primary section.toc').fix();\n *\n * To do the same, but stick 100 pixels before it reaches the top of the page:\n *\n *     $('aside.primary section.toc').fix({\n *         startOffset: 100\n *     });\n *\n * To stay stuck to the top of the page for 500 pixels of vertical scrolling:\n *\n *     $('.sticky').fix({\n *         startOffset: 100,\n *         duration: 500\n *     });\n *\n *\n *\n * OPTIONS\n *\n *     startOffset (integer, default: 0)\n *         How many pixels from the top of the viewport to start sticking.\n *\n *     endOffset (integer)\n *         If specified and different than startOffset, the sticky element will\n *         animate as you scroll from the startOffset to the endOffset\n *         while the element is fixed.\n *\n *     duration (integer)\n *         If specified, the element will unstick once this number of\n *         pixels has been scrolled.\n *\n *     until (selector)\n *         If specified, the sticky element unsticks when this element scrolls even\n *         with the sticked element.\n *\n *     untilVisible (selector)\n *         If speicifed, the sticky element unstick when any of this element scrolls\n *         into view.\n *\n *     stopEarly (integer, default: 0)\n *         If specified, unsticks the element when it reaches this distance\n *         from the top of an 'until' element.\n *\n *     classWhileFixed (string, default \"element-fixed\")\n *         This lets you specify a class to add to the element while it's stuck. Defaults to \"element-fixed\".\n */\n\n'use strict';\n\nimport $ from 'jquery';\n\nvar FixedElement = function(elem, options) {\n    var defaults = {\n        classWhileFixed: 'element-fixed',\n        startOffset: 0,\n        stopEarly: 0\n    };\n\n    options = $.extend(defaults, options);\n\n    var that = this,\n        state = 'init',\n        $elem = $(elem),\n        $dupe = $elem\n        .clone()\n        .addClass('fixed-element-duplicate')\n        .css({\n            visibility: 'hidden'\n        })\n        .insertAfter($elem);\n\n    if ('until' in options) {\n        options.$until = $(options.until);\n    }\n\n    if ('untilVisible' in options) {\n        options.$untilVisible = $(options.untilVisible);\n    }\n\n    $elem.css({\n        position: 'absolute'\n    });\n\n    this.startAt = function() {\n        return $dupe.offset().top - options.startOffset;\n    };\n\n    this.endAt = function() {\n        var offset = this.startAt();\n\n        if ('duration' in options) {\n            offset += options.duration;\n        } else if ('until' in options) {\n            offset = options.$until.offset().top;\n        } else if ('untilVisible' in options) {\n            offset = options.$untilVisible.offset().top - $(window).height();\n        } else {\n            offset = $(document).height();\n        }\n\n        if ('endOffset' in options) {\n            offset -= options.endOffset;\n        } else {\n            offset -= options.startOffset;\n        }\n\n        return offset - options.stopEarly;\n    };\n\n    this.release = function(top) {\n        state = 'released';\n        $elem.removeClass(options.classWhileFixed)\n            .css({\n                position: 'absolute',\n                top: '',\n                transform: 'translateZ(0) translate(0, ' + top + 'px)'\n            });\n    };\n\n    this.fix = function(additionalOffset) {\n        var offset = options.startOffset + additionalOffset;\n\n        state = 'fixed';\n        requestAnimationFrame(function() {\n            $elem.addClass(options.classWhileFixed)\n                .css({\n                    position: 'fixed',\n                    top: offset,\n                    transform: ''\n                });\n        });\n    };\n\n    this.update = function() {\n        var scrollTop   = $(window).scrollTop();\n        var start       = that.startAt();\n        var end         = that.endAt();\n        var diff        = end - start;\n        var currentDiff = scrollTop - start;\n        var diffOffsets = (options.endOffset - options.startOffset) || 0;\n\n        // Above start\n        if (scrollTop <= start) {\n            if (state == 'fixed' || state == 'init') {\n                that.release(0);\n            }\n\n        // Between start and end\n        } else if (scrollTop <= end) {\n            if (diffOffsets) {\n                that.fix(diffOffsets * currentDiff / diff);\n            } else if (state == 'released' || state == 'init') {\n                that.fix(0);\n            }\n\n        // Below end\n        } else {\n            if (state == 'fixed' || state == 'init') {\n                that.release(diff + diffOffsets);\n            }\n        }\n    };\n\n    $(window).on('scroll resize fix:update', this.update);\n    this.update();\n};\n\n$.fn.fix = function(options) {\n    this.each(function() {\n        return new FixedElement(this, options);\n    });\n};\n"],"sourceRoot":""}